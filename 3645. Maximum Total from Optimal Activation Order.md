# Medium

You are given two integer arrays $value$ and $limit$, both of length $n$.

Initially, all elements are inactive. You may activate them in any order.

- To activate an inactive element at index $i$, the number of currently active elements must be strictly less than $limit[i]$.
- When you activate the element at index $i$, it adds $value[i]$ to the total activation value (i.e., the sum of $value[i]$ for all elements that have undergone activation operations).
- After each activation, if the number of currently active elements becomes $x$, then all elements $j$ with $limit[j] \leq x$ become permanently inactive, even if they are already active.

Return the maximum total you can obtain by choosing the activation order optimally.

```cpp
class Solution {
public:
    long long maxTotal(vector<int>& value, vector<int>& limit) {
        int arraySize = value.size();
        
        // Group values by their corresponding limits
        map<int, vector<int>> limitGroups;
        for (int i = 0; i < arraySize; ++i) {
            limitGroups[limit[i]].push_back(value[i]);
        }
        
        long long totalSum = 0;
        
        // Process each limit group to maximize the sum
        for (auto& [currentLimit, values] : limitGroups) {
            // We can select at most min(limit, available_values) items
            int maxSelectable = min(currentLimit, (int)values.size());
            
            // Sort values in descending order to pick the largest ones first
            sort(values.rbegin(), values.rend());
            
            // Sum the top 'maxSelectable' values from this group
            totalSum += accumulate(values.begin(), 
                                 values.begin() + maxSelectable, 
                                 0LL);
        }
        
        return totalSum;
    }
};
```
