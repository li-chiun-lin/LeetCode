# Hard

You are given an integer array $nums$ of length $n$ and a 2D integer array $queries$ of size $q$, where $queries[i] = [l_i, r_i, k_i, v_i]$.

For each query, you must apply the following operations in order:

- Set $idx = l_i$.
- While $idx \leq r_i$:
  - Update: $nums[idx] = (nums[idx] \times v_i) \mod (10^9 + 7)$
  - Set $idx += k_i$.

Return the bitwise XOR of all elements in $nums$ after processing all queries.

```cpp
class Solution {
private:
    static constexpr long long MOD = 1e9 + 7;
    
    // Fast modular exponentiation using binary lifting
    long long fastPow(long long base, long long exp) const {
        long long result = 1;
        base %= MOD;
        while (exp > 0) {
            if (exp & 1) result = (result * base) % MOD;
            base = (base * base) % MOD;
            exp >>= 1;
        }
        return result;
    }
    
    // Modular multiplicative inverse using Fermat's little theorem
    long long modInv(long long a) const {
        return fastPow(a, MOD - 2);
    }
    
    // Safe map access with default value
    long long getWithDefault(const unordered_map<int, long long>& m, int key, long long defaultVal) const {
        auto it = m.find(key);
        return it != m.end() ? it->second : defaultVal;
    }
    
    // Extract and remove value from map
    long long popValue(unordered_map<int, long long>& m, int key, long long defaultVal) {
        auto it = m.find(key);
        if (it == m.end()) return defaultVal;
        long long val = it->second;
        m.erase(it);
        return val;
    }

public:
    int xorAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {
        const int n = nums.size();
        const int threshold = sqrt(n) + 1;
        
        // Difference arrays for small step sizes
        vector<unordered_map<int, long long>> diffArrays(threshold);
        
        // Process queries with sqrt decomposition
        for (const auto& query : queries) {
            const int left = query[0], right = query[1], step = query[2];
            const long long multiplier = query[3];
            
            if (step >= threshold) {
                // Large steps: direct multiplication (few operations)
                for (int idx = left; idx <= right; idx += step) {
                    nums[idx] = (1LL * nums[idx] * multiplier) % MOD;
                }
            } else {
                // Small steps: use difference array technique
                auto& events = diffArrays[step];
                
                // Mark start of multiplication range
                long long startVal = getWithDefault(events, left, 1);
                events[left] = (startVal * multiplier) % MOD;
                
                // Calculate end position and mark multiplication stop
                const int endPos = right + (step - (right - left) % step);
                if (endPos < n) {
                    const long long invMultiplier = modInv(multiplier);
                    long long endVal = getWithDefault(events, endPos, 1);
                    events[endPos] = (endVal * invMultiplier) % MOD;
                }
            }
        }
        
        // Apply difference arrays using sweep line technique
        for (int stepSize = 1; stepSize < threshold; ++stepSize) {
            auto& eventMap = diffArrays[stepSize];
            
            while (!eventMap.empty()) {
                const int startPos = eventMap.begin()->first;
                long long cumulativeMultiplier = 1;
                
                // Sweep through arithmetic sequence
                for (int pos = startPos; pos < n; pos += stepSize) {
                    cumulativeMultiplier = (cumulativeMultiplier * popValue(eventMap, pos, 1LL)) % MOD;
                    nums[pos] = (1LL * nums[pos] * cumulativeMultiplier) % MOD;
                }
            }
        }
        
        // Compute final XOR using functional approach
        return accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());
    }
};
```
