# Medium

You are given an integer array $nums$ of length $n$.

You start at index $0$, and your goal is to reach index $n - 1$.

From any index $i$, you may perform one of the following operations:

- Adjacent Step: Jump to index $i + 1$ or $i - 1$, if the index is within bounds.
- Prime Teleportation: If $nums[i]$ is a prime number $p$, you may instantly jump to any index $j \ne i$ such that $nums[j] \mod p == 0$.

Return the minimum number of jumps required to reach index $n - 1$.

```cpp
class Solution {
public:
    // Function to compute the minimum number of jumps to reach the end of the array
    // using prime factor jumps, +1, or -1 steps
    int minJumps(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return 0;

        const int MAX = *max_element(begin(nums), end(nums));
        vector<int> spf(MAX + 1); // Smallest Prime Factor for each number up to MAX

        // Sieve to compute the smallest prime factor (SPF) for all numbers up to MAX
        for (int i = 2; i <= MAX; ++i) {
            if (spf[i] == 0) {
                spf[i] = i;
                if (1LL * i * i <= MAX) {
                    for (long long j = 1LL * i * i; j <= MAX; j += i) {
                        if (spf[j] == 0) spf[j] = i;
                    }
                }
            }
        }

        // Map each prime factor to the list of indices in nums where that prime appears
        unordered_map<int, vector<int>> primeToIndices;
        primeToIndices.reserve(n * 2); // Reserve space to reduce rehashing

        for (int i = 0; i < n; ++i) {
            int val = nums[i];
            while (val > 1) {
                int p = spf[val];
                primeToIndices[p].push_back(i); // Index i is associated with prime factor p
                while (val % p == 0) val /= p;  // Remove all instances of p
            }
        }

        // BFS to compute minimum number of jumps
        vector<int> dist(n, -1); // Distance from index 0
        queue<int> q;
        dist[0] = 0;
        q.push(0);

        while (!q.empty()) {
            int idx = q.front();
            q.pop();
            int nextDist = dist[idx] + 1;

            // Try jumping to index + 1
            if (idx + 1 < n && dist[idx + 1] == -1) {
                dist[idx + 1] = nextDist;
                q.push(idx + 1);
            }

            // Try jumping to index - 1
            if (idx - 1 >= 0 && dist[idx - 1] == -1) {
                dist[idx - 1] = nextDist;
                q.push(idx - 1);
            }

            // Try jumping to all indices that share a prime factor with nums[idx]
            int val = nums[idx];
            if (val > 1 && spf[val] == val) { // val is a prime (shortcut check)
                auto it = primeToIndices.find(val);
                if (it != primeToIndices.end()) {
                    for (int otherIdx : it->second) {
                        if (dist[otherIdx] == -1) {
                            dist[otherIdx] = nextDist;
                            q.push(otherIdx);
                        }
                    }
                    primeToIndices.erase(it); // Remove to avoid redundant future processing
                }
            }

            // Early exit if destination is reached
            if (dist[n - 1] != -1) return dist[n - 1];
        }

        // Return the minimum jumps required to reach the last index
        return dist[n - 1];
    }
};
```
