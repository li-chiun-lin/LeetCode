# Medium

Given two integers $n$ and $k$, split the number $n$ into exactly $k$ positive integers such that the product of these integers is equal to $n$.

Return any one split in which the maximum difference between any two numbers is minimized. You may return the result in any order.

```cpp
class Solution {
public:
    // Compute and return all positive divisors of n (sorted, unique)
    vector<long long> getDivisors(long long n) {
        vector<long long> d;
        for (long long i = 1; i * i <= n; ++i) {
            if (n % i == 0) {
                d.push_back(i);
                if (i * i != n) d.push_back(n / i); // add complement divisor
            }
        }
        sort(d.begin(), d.end());
        d.erase(unique(d.begin(), d.end()), d.end());
        return d;
    }

    vector<int> minDifference(int n, int k) {
        // Special case: n == 1
        // The only valid split is [1, 1, ..., 1]
        if (n == 1) return vector<int>(k, 1);

        // Step 1: Collect all divisors of n
        vector<long long> divs = getDivisors(n);

        // Step 2: Variables to track the best solution
        vector<long long> best;        // best split found
        long long bestDiff = LLONG_MAX; // minimized (max - min)
        vector<long long> path;        // current path during DFS

        // Step 3: Define recursive DFS using a lambda
        // Arguments:
        //   startIdx = index in divisors list (to ensure non-decreasing order)
        //   picked   = how many numbers have been picked so far
        //   prod     = product of chosen numbers so far
        //   curMin   = minimum of chosen numbers
        //   curMax   = maximum of chosen numbers
        function<void(int,int,long long,long long,long long)> dfs =
            [&](int startIdx, int picked, long long prod, long long curMin, long long curMax) {
                // Base case: about to place the last factor
                if (picked == k - 1) {
                    // Must divide evenly
                    if (n % prod != 0) return;
                    long long last = n / prod;

                    // Keep numbers in non-decreasing order
                    if (last < divs[startIdx]) return;

                    // Update min/max for this candidate path
                    long long mn = (picked > 0 ? min(curMin, last) : last);
                    long long mx = (picked > 0 ? max(curMax, last) : last);
                    long long diff = mx - mn;

                    // Update the best answer if this split is tighter
                    if (diff < bestDiff) {
                        bestDiff = diff;
                        best = path;
                        best.push_back(last);
                    }
                    return;
                }

                // Otherwise, try choosing another divisor
                long long remainder = n / prod; // what's left to factorize

                for (int i = startIdx; i < (int)divs.size(); ++i) {
                    long long d = divs[i];

                    // Skip if this divisor doesn't divide the remainder
                    if (remainder % d != 0) continue;

                    // Choose this divisor
                    path.push_back(d);

                    long long mn = (picked > 0 ? min(curMin, d) : d);
                    long long mx = (picked > 0 ? max(curMax, d) : d);

                    // Recurse (note: pass i, not i+1, to allow repeated factors)
                    dfs(i, picked + 1, prod * d, mn, mx);

                    // Backtrack
                    path.pop_back();
                }
            };

        // Step 4: Launch DFS search
        dfs(0, 0, 1, LLONG_MAX, LLONG_MIN);

        // Step 5: Convert result to vector<int> and return
        return vector<int>(best.begin(), best.end());
    }
};
```
