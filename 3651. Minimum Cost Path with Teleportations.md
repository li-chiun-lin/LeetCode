# Hard

You are given a $m \times n$ 2D integer array $grid$ and an integer $k$. You start at the top-left cell $(0, 0)$ and your goal is to reach the bottom‚Äêright cell $(m - 1, n - 1)$.

There are two types of moves available:

- Normal move: You can move right or down from your current cell $(i, j)$, i.e. you can move to $(i, j + 1)$ (right) or $(i + 1, j)$ (down). The cost is the value of the destination cell.

- Teleportation: You can teleport from any cell $(i, j)$, to any cell $(x, y)$ such that $grid[x][y] \leq grid[i][j]$; the cost of this move is $0$. You may teleport at most $k$ times.

Return the minimum total cost to reach cell $(m - 1, n - 1)$ from $(0, 0)$.

```cpp
class Solution {
public:
    const int INF = 1e9;
    
    // Applies normal moves (right and down) to minimize costs using DP
    void relaxWithNormalMoves(vector<vector<int>>& dp, vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        dp[0][0] = 0;  // Starting position has zero cost
        
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // Move down: cost is current cell's value
                if (i > 0) {
                    dp[i][j] = min(dp[i][j], dp[i-1][j] + grid[i][j]);
                }
                
                // Move right: cost is current cell's value  
                if (j > 0) {
                    dp[i][j] = min(dp[i][j], dp[i][j-1] + grid[i][j]);
                }
            }
        }
    }
    
    int minCost(vector<vector<int>>& grid, int k) {
        int m = grid.size(), n = grid[0].size();
        
        // === Coordinate Compression ===
        // Collect all unique values in the grid for efficient teleportation processing
        vector<int> uniqueValues;
        for (const auto& row : grid) {
            for (int val : row) {
                uniqueValues.push_back(val);
            }
        }
        
        // Sort and remove duplicates
        sort(uniqueValues.begin(), uniqueValues.end());
        uniqueValues.erase(unique(uniqueValues.begin(), uniqueValues.end()), uniqueValues.end());
        
        // Create mapping: value -> compressed index
        unordered_map<int, int> valueToIndex;
        for (int i = 0; i < uniqueValues.size(); i++) {
            valueToIndex[uniqueValues[i]] = i;
        }
        
        int numUniqueValues = uniqueValues.size();
        
        // === DP Setup ===
        vector<vector<int>> prevDP(m, vector<int>(n, INF));
        vector<vector<int>> currDP;
        
        // Base case: solve with 0 teleportations (normal moves only)
        relaxWithNormalMoves(prevDP, grid);
        int answer = prevDP[m-1][n-1];
        
        // === Process Each Teleportation Round ===
        for (int teleportRound = 1; teleportRound <= k; teleportRound++) {
            // Array to store minimum cost to reach each unique value
            vector<int> minCostByValue(numUniqueValues, INF);
            currDP.assign(m, vector<int>(n, INF));
            
            // Step 1: Find minimum cost to reach any cell with each unique value
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    int compressedIndex = valueToIndex[grid[i][j]];
                    minCostByValue[compressedIndex] = min(minCostByValue[compressedIndex], prevDP[i][j]);
                }
            }
            
            // Step 2: Apply suffix minimum to handle teleportation constraint
            // After this step, minCostByValue[i] = minimum cost to reach any cell 
            // with value >= uniqueValues[i] (because we can teleport from higher to lower values)
            for (int i = numUniqueValues - 2; i >= 0; i--) {
                minCostByValue[i] = min(minCostByValue[i], minCostByValue[i + 1]);
            }
            
            // Step 3: Apply teleportation - update each cell with the best cost
            // from any cell that can teleport to it
            for (int i = 0; i < m; i++) {
                for (int j = 0; j < n; j++) {
                    int compressedIndex = valueToIndex[grid[i][j]];
                    // Can teleport from any cell with value >= grid[i][j]
                    currDP[i][j] = minCostByValue[compressedIndex];
                }
            }
            
            // Step 4: Apply normal moves to spread from teleportation landing points
            relaxWithNormalMoves(currDP, grid);
            
            // Update for next iteration
            prevDP = currDP;
            answer = prevDP[m-1][n-1];
        }
        
        return answer;
    }
};
```
