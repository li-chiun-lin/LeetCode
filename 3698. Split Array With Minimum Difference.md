# Medium

You are given an integer array $nums$.

Split the array into exactly two subarrays, $left$ and $right$, such that $left$ is strictly increasing and $right$ is strictly decreasing.

Return the minimum possible absolute difference between the sums of $left$ and $right$. If no valid split exists, return $-1$.

```cpp
class Solution {
public:
    long long splitArray(vector<int>& nums) {
        int n = nums.size();
        
        // --- PRECOMPUTE VALIDITY CONDITIONS ---
        
        // canBeIncreasing[i] = true if nums[0...i] can form a strictly increasing sequence
        vector<bool> canBeIncreasing(n, true);
        for (int i = 1; i < n; ++i) {
            canBeIncreasing[i] = canBeIncreasing[i - 1] && (nums[i - 1] < nums[i]);
        }
        
        // canBeDecreasing[i] = true if nums[i...n-1] can form a strictly decreasing sequence  
        vector<bool> canBeDecreasing(n, true);
        for (int i = n - 2; i >= 0; --i) {
            canBeDecreasing[i] = canBeDecreasing[i + 1] && (nums[i] > nums[i + 1]);
        }
        
        // --- PRECOMPUTE PREFIX SUMS ---
        // prefixSum[i] = sum of nums[0...i-1] (0-indexed, prefixSum[0] = 0)
        vector<long long> prefixSum(n + 1, 0);
        for (int i = 0; i < n; ++i) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }
        
        long long totalSum = prefixSum[n];
        long long minDifference = LLONG_MAX;
        
        // --- TRY ALL POSSIBLE SPLIT POINTS ---
        // Split array at position i: left = nums[0...i], right = nums[i+1...n-1]
        for (int splitPoint = 0; splitPoint + 1 < n; ++splitPoint) {
            
            // Check if this split creates valid increasing/decreasing parts
            bool leftIsIncreasing = canBeIncreasing[splitPoint];
            bool rightIsDecreasing = canBeDecreasing[splitPoint + 1];
            
            if (leftIsIncreasing && rightIsDecreasing) {
                // Calculate sums of left and right parts
                long long leftSum = prefixSum[splitPoint + 1];  // Sum of nums[0...splitPoint]
                long long rightSum = totalSum - leftSum;        // Sum of nums[splitPoint+1...n-1]
                
                // Update minimum absolute difference
                long long currentDifference = abs(leftSum - rightSum);
                minDifference = min(minDifference, currentDifference);
            }
        }
        
        // Return result: -1 if no valid split found, otherwise minimum difference
        return minDifference == LLONG_MAX ? -1 : minDifference;
    }
};
```
