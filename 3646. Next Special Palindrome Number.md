# Hard

You are given an integer $n$.

A number is called special if:

- It is a palindrome .
- Every digit $k$ in the number appears exactly $k$ times.

Return the smallest special number strictly greater than $n$.

```cpp
class Solution {
    bool getBit(int number, int position) {
        return number & (1 << position);
    }
    
    void generatePalindromes(vector<long long>& candidates, const vector<int>& chosenDigits) {
        // Build the first half of the palindrome and identify the middle element
        vector<int> firstHalf;
        int middleElement = -1;
        
        for (int digit : chosenDigits) {
            // If digit appears odd times, one instance goes in the middle
            if (digit % 2 == 1) {
                middleElement = digit;
            }
            
            // Add half of the digit occurrences to the first half
            int halfCount = digit / 2;
            for (int i = 0; i < halfCount; ++i) {
                firstHalf.push_back(digit);
            }
        }
        
        // Generate all permutations of the first half to create different palindromes
        sort(firstHalf.begin(), firstHalf.end());
        
        do {
            long long palindrome = 0LL;
            
            // Build the first half of the number
            for (int digit : firstHalf) {
                palindrome = palindrome * 10LL + digit;
            }
            
            // Add the middle element if it exists (for odd-length palindromes)
            if (middleElement != -1) {
                palindrome = palindrome * 10LL + middleElement;
            }
            
            // Mirror the first half to complete the palindrome
            for (int i = firstHalf.size() - 1; i >= 0; --i) {
                int digit = firstHalf[i];
                palindrome = palindrome * 10LL + digit;
            }
            
            candidates.push_back(palindrome);
            
        } while (next_permutation(firstHalf.begin(), firstHalf.end()));
    }
    
public:
    long long specialPalindrome(long long n) {
        vector<long long> candidates;
        vector<int> availableDigits = {1, 2, 3, 4, 5, 6, 7, 8, 9};
        
        // Try all possible combinations of digits using bitmask (2^9 = 512 combinations)
        for (int mask = 0; mask < (1 << 9); ++mask) {
            vector<int> chosenDigits;
            
            // Extract digits based on the current bitmask
            for (int position = 0; position < 9; ++position) {
                if (getBit(mask, position)) {
                    chosenDigits.push_back(availableDigits[position]);
                }
            }
            
            // Validate the chosen digit combination
            int oddDigitCount = 0;
            int totalLength = 0;
            
            for (int digit : chosenDigits) {
                if (digit % 2 == 1) oddDigitCount++;
                totalLength += digit;
            }
            
            // Skip invalid combinations:
            // - More than 1 digit with odd frequency (can't form palindrome)
            // - Total length â‰¥ 17 (avoid overflow in long long)
            if (oddDigitCount > 1) continue;
            if (totalLength >= 17) continue;
            
            // Generate all palindromes from this valid combination
            generatePalindromes(candidates, chosenDigits);
        }
        
        // Sort all candidates to enable binary search
        sort(candidates.begin(), candidates.end());
        
        // Find the first palindrome strictly greater than n
        auto iterator = upper_bound(candidates.begin(), candidates.end(), n);
        
        // Return the result or -1 if no valid palindrome exists
        return iterator != candidates.end() ? *iterator : -1;
    }
};
```
