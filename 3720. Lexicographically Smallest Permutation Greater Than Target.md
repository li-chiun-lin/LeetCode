# Medium

You are given two strings $s$ and $target$, both having length $n$, consisting of lowercase English letters.

Return the lexicographically smallest permutation of $s$ that is strictly greater than $target$. If no permutation of $s$ is lexicographically strictly greater than $target$, return an empty string.

```cpp
class Solution
{
public:
    // Recursive helper to build the smallest lexicographically greater permutation
    bool dfs(vector<char>& path, map<char, int>& freq, string& target, bool alreadyGreater, string& result)
    {
        int n = target.size();

        // Stop early if result already found
        if (!result.empty())
            return true;

        // Base case: full-length string formed
        if (path.size() == n)
        {
            if (alreadyGreater)
            {
                result.assign(path.begin(), path.end());
                return true;
            }
            return false;
        }

        int pos = path.size();

        // Try each available character in lexicographic order
        for (auto& [ch, count] : freq)
        {
            if (count == 0)
                continue;

            // If not yet greater, skip smaller characters than target[pos]
            if (!alreadyGreater && ch < target[pos])
                continue;

            // Choose current character
            path.push_back(ch);
            --count;

            bool newGreater = alreadyGreater || (ch > target[pos]);

            // Recursive call
            if (dfs(path, freq, target, newGreater, result))
                return true;

            // Backtrack
            ++count;
            path.pop_back();
        }

        return false;
    }

    string lexGreaterPermutation(string s, string target)
    {
        map<char, int> freq;
        for (char c : s)
            ++freq[c];

        vector<char> path;
        string result;

        dfs(path, freq, target, false, result);

        // Optional: uncomment to avoid returning equal string
        // if (result == target) return "";

        return result;
    }
};
```
