# Medium

There is a dungeon with $n \times m$ rooms arranged as a grid.

You are given a 2D array $moveTime$ of size $n \times m$, where $moveTime[i][j]$ represents the minimum time in seconds when you can start moving to that room. You start from the room $(0, 0)$ at time $t = 0$ and can move to an adjacent room. Moving between adjacent rooms takes one second for one move and two seconds for the next, alternating between the two.

Return the minimum time to reach the room $(n - 1, m - 1)$.

```cpp
class Solution {
public:
    int minTimeToReach(vector<vector<int>>& moveTime) {
        int n = size(moveTime);
        int m = size(moveTime[0]);
        int d[] = {1, 0, -1, 0, 1};

        // dp[0] for odd rounds, 
        // dp[1] for even rounds.
        vector<vector<vector<int>>> dp(2, 
            vector<vector<int>>(n, 
                vector<int>(m, 2e9)));

        priority_queue<tuple<int, int, int, int>, 
            vector<tuple<int, int, int, int>>, 
            greater<>> que;
        que.push({0, 0, 0, 0});
        dp[0][0][0] = 0;

        while (size(que))
        {
            auto [v, r, x, y] = que.top();
            que.pop();

            // alternative round
            int rr = 1 - r;

            for (int k = 0; k < 4; ++k)
            {
                int xx = x + d[k];
                int yy = y + d[k + 1];

                if (0 <= xx && xx < n && 0 <= yy && yy < m)
                {
                    // if r == 0, then add 1 second
                    // if r == 1, then add 2 second
                    // thus, in general, add 1 + r second
                    int t = max(dp[r][x][y], moveTime[xx][yy]) + 1 + r;

                    if (dp[rr][xx][yy] > t)
                    {
                        dp[rr][xx][yy] = t;
                        que.push({t, rr, xx, yy});
                    }
                }
            }
        }

        return min(dp[0][n - 1][m - 1], dp[1][n - 1][m - 1]);
    }
};
```
