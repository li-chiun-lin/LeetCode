# Medium

You are given an integer array $nums$.

Your task is to find two distinct indices $i$ and $j$ such that the product $nums[i] \times nums[j]$ is maximized, and the binary representations of $nums[i]$ and $nums[j]$ do not share any common set bits.

Return the maximum possible product of such a pair. If no such pair exists, return $0$.

```cpp
class Solution {
public:
    long long maxProduct(vector<int>& nums) {
        // Step 1: Find the maximum number in nums
        int max_n = *max_element(nums.begin(), nums.end());

        // Step 2: Find the highest set bit (MSB) of max_n
        int msb = log2(max_n);

        // Step 3: Define a mask that covers all bits up to msb
        // Example: if msb = 4, then max_mask = 11111 (binary) = 31
        int max_mask = (1 << (msb + 1)) - 1;

        // Step 4: Initialize dp array
        // dp[mask] will store the maximum value from nums that is a subset of 'mask'
        vector<int> dp(max_mask + 1, 0);

        // Step 5: Fill dp with initial values (each number itself)
        for (int x : nums) {
            dp[x] = x;
        }

        // Step 6: SOS DP (Sum Over Subsets DP)
        // For each bit position, update dp so that dp[mask] becomes
        // the maximum number among all subsets of mask.
        for (int b = 0; b <= msb; ++b) {
            for (int mask = 0; mask < max_mask; ++mask) {
                if (mask & (1 << b)) {
                    dp[mask] = max(dp[mask], dp[mask ^ (1 << b)]);
                }
            }
        }

        // Step 7: Compute maximum product
        long long ans = 0;
        for (int n : nums) {
            // Complement mask = all bits except those in n
            int complement = max_mask ^ n;
            // dp[complement] = max number from nums that has no common set bit with n
            ans = max(ans, 1LL * n * dp[complement]);
        }

        return ans;
    }
};
```
