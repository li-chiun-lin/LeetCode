# Medium

You are given an integer array $nums$ of length $n$, where $nums$ is a permutation of the numbers in the range $[0..n - 1]$.

You may swap elements at indices $i$ and $j$ only if $nums[i] \And nums[j] == k$, where $\And$ denotes the bitwise AND operation and $k$ is a non-negative integer.

Return the maximum value of $k$ such that the array can be sorted in non-decreasing order using any number of such swaps. If $nums$ is already sorted, return $0$.

```cpp
class Solution {
public:
    int sortPermutation(vector<int>& nums) {
        int arraySize = nums.size();
        int bitwiseResult = INT_MAX;  // Start with all bits set to 1
        
        // Check each position to see if the element is out of place
        for (int position = 0; position < arraySize; ++position) {
            // If element at current position doesn't match its expected value
            if (nums[position] != position) {
                // Perform bitwise AND with the misplaced element
                bitwiseResult &= nums[position];
            }
        }
        
        // If no misplaced elements were found, return 0
        // Otherwise, return the accumulated bitwise AND result
        return bitwiseResult == INT_MAX ? 0 : bitwiseResult;
    }
};
```
