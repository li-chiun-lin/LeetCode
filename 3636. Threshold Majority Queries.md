# Hard

You are given an integer array $nums$ of length $n$ and an array $queries$, where $queries[i] = [l_i, r_i, threshold_i]$.

Return an array of integers $ans$ where $ans[i]$ is equal to the element in the subarray $nums[l_i...r_i]$ that appears at least $threshold_i$ times, selecting the element with the highest frequency (choosing the smallest in case of a tie), or $-1$ if no such element exists.

```cpp
class Solution {
public:
    vector<int> subarrayMajority(vector<int>& nums, vector<vector<int>>& queries) {
        int n = nums.size();

        // Step 1: Preprocess positions of each value
        unordered_map<int, vector<int>> positions;
        for (int i = 0; i < n; ++i) {
            positions[nums[i]].push_back(i);
        }

        vector<int> result;

        for (const auto& q : queries) {
            int l = q[0], r = q[1], threshold = q[2];

            int answer = -1;
            int bestFreq = threshold - 1;

            // Step 2: Try all unique values (brute force over candidates)
            for (const auto& [val, posList] : positions) {
                // If total occurrences < threshold, skip early
                if ((int)posList.size() < threshold) continue;

                // Binary search: count occurrences of `val` in [l, r]
                int lo = lower_bound(posList.begin(), posList.end(), l) - posList.begin();
                int hi = upper_bound(posList.begin(), posList.end(), r) - posList.begin();
                int count = hi - lo;

                if (count >= threshold) {
                    if (count > bestFreq || (count == bestFreq && val < answer)) {
                        answer = val;
                        bestFreq = count;
                    }
                }
            }

            result.push_back(answer);
        }

        return result;
    }
};
```
