# Medium

Given an $m \times n$ binary grid $grid$ where:

- $grid[i][j] == 0$ represents an empty cell, and
- $grid[i][j] == 1$ represents a mirror.

A robot starts at the top-left corner of the grid $(0, 0)$ and wants to reach the bottom-right corner $(m - 1, n - 1)$. It can move only right or down. If the robot attempts to move into a mirror cell, it is reflected before entering that cell:

- If it tries to move right into a mirror, it is turned down and moved into the cell directly below the mirror.
- If it tries to move down into a mirror, it is turned right and moved into the cell directly to the right of the mirror.

If this reflection would cause the robot to move outside the $grid$ boundaries, the path is considered invalid and should not be counted.

Return the number of unique valid paths from $(0, 0)$ to $(m - 1, n - 1)$.

Since the answer may be very large, return it modulo $10^9 + 7$.

Note: If a reflection moves the robot into a mirror cell, the robot is immediately reflected again based on the direction it used to enter that mirror: if it entered while moving right, it will be turned down; if it entered while moving down, it will be turned right. This process will continue until either the last cell is reached, the robot moves out of bounds or the robot moves to a non-mirror cell.

```cpp
class Solution 
{
    long long mod = 1e9 + 7;  // Modulo to avoid overflow

    // Depth-First Search with memoization
    long long dfs(vector<vector<int>>& grid, int i, int j, bool movingRight, 
                  vector<vector<vector<long long>>>& dp)
    {
        int m = grid.size();
        int n = grid[0].size();

        // Reached bottom-right corner, count as one valid path
        if (i == m - 1 && j == n - 1)
            return 1;

        // Return cached result if already computed
        if (dp[i][j][movingRight] != -1)
            return dp[i][j][movingRight];

        long long ways = 0;

        // Case 1: Current cell is blocked in one direction
        if (grid[i][j] == 1)
        {
            if (movingRight)  
            {
                // If last move was right, we can only go down
                if (i + 1 < m)
                    ways = dfs(grid, i + 1, j, false, dp) % mod;
            }
            else  
            {
                // If last move was down, we can only go right
                if (j + 1 < n)
                    ways = dfs(grid, i, j + 1, true, dp) % mod;
            }
        }
        // Case 2: Cell allows both directions
        else
        {
            if (i + 1 < m)  
                ways += dfs(grid, i + 1, j, false, dp);

            if (j + 1 < n)  
                ways += dfs(grid, i, j + 1, true, dp);
        }

        // Save result in DP table and apply modulo
        return dp[i][j][movingRight] = ways % mod;
    }

public:
    int uniquePaths(vector<vector<int>>& grid) 
    {
        int m = grid.size();
        int n = grid[0].size();

        // 3D DP: dp[i][j][dir], where dir = 0 (down), 1 (right)
        vector<vector<vector<long long>>> dp(
            m, vector<vector<long long>>(n, vector<long long>(2, -1))
        );

        long long totalWays = 0;

        // Start DFS assuming first move is right
        totalWays += dfs(grid, 0, 0, true, dp);

        return totalWays % mod;
    }
};
```
