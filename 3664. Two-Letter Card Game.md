# Medium

You are given a deck of cards represented by a string array $cards$, and each card displays two lowercase letters.

You are also given a letter $x$. You play a game with the following rules:

- Start with $0$ points.
- On each turn, you must find two compatible cards from the deck that both contain the letter $x$ in any position.
- Remove the pair of cards and earn $1$ point.
- The game ends when you can no longer find a pair of compatible cards.

Return the maximum number of points you can gain with optimal play.

Two cards are compatible if the strings differ in exactly $1$ position.

```cpp
class Solution {
public:
    int score(vector<string>& cards, char x) {
        /*
         * Problem: Choose optimal scoring strategy to MINIMIZE total score
         * 
         * Two scoring strategies:
         * Strategy 1: Each pair worth 2 points (cannot use remaining double-x cards)
         * Strategy 2: Each pair worth 1 point (can pair remaining double-x cards for 1 point each)
         * 
         * Card types:
         * - Type A: x in first position only (e.g., "xa", "xb") 
         * - Type B: x in second position only (e.g., "ax", "bx")
         * - Type C: x in both positions (e.g., "xx")
         * 
         * Valid pairings:
         * - Type A with Type A: if second chars differ
         * - Type B with Type B: if first chars differ  
         * - Type C with Type A or Type B: always valid
         */
        
        int maxFreqTypeA = 0;           // max frequency of any second char in Type A
        int totalTypeA = 0;             // total Type A cards
        int maxFreqTypeB = 0;           // max frequency of any first char in Type B  
        int totalTypeB = 0;             // total Type B cards
        int doubleXCards = 0;           // Type C cards
        
        vector<int> secondCharFreq(26, 0);  // frequency of second chars in Type A
        vector<int> firstCharFreq(26, 0);   // frequency of first chars in Type B
        
        // Categorize cards and count frequencies
        for (const string& card : cards) {
            char first = card[0];
            char second = card[1];
            
            if (first == x && second == x) {
                doubleXCards++;
            }
            else if (first == x) {
                secondCharFreq[second - 'a']++;
                maxFreqTypeA = max(maxFreqTypeA, secondCharFreq[second - 'a']);
                totalTypeA++;
            }
            else if (second == x) {
                firstCharFreq[first - 'a']++;
                maxFreqTypeB = max(maxFreqTypeB, firstCharFreq[first - 'a']);
                totalTypeB++;
            }
        }
        
        int pairs = 0;
        int remainingTypeA = 0;
        int remainingTypeB = 0;
        
        // Optimal pairing for Type A cards
        if (maxFreqTypeA > (totalTypeA - maxFreqTypeA)) {
            // Most frequent second char appears more than half the time
            // Pair all minority chars with the majority char
            pairs += (totalTypeA - maxFreqTypeA);
            remainingTypeA = maxFreqTypeA - (totalTypeA - maxFreqTypeA);
        } else {
            // No char dominates - pair optimally within each char group
            pairs += totalTypeA / 2;
            remainingTypeA = totalTypeA % 2;
        }
        
        // Optimal pairing for Type B cards (same logic)
        if (maxFreqTypeB > (totalTypeB - maxFreqTypeB)) {
            pairs += (totalTypeB - maxFreqTypeB);
            remainingTypeB = maxFreqTypeB - (totalTypeB - maxFreqTypeB);
        } else {
            pairs += totalTypeB / 2;
            remainingTypeB = totalTypeB % 2;
        }
        
        // Use Type C cards to complete remaining Type A and B cards
        int totalRemaining = remainingTypeA + remainingTypeB;
        int usedDoubleX = min(totalRemaining, doubleXCards);
        int unusedDoubleX = doubleXCards - usedDoubleX;
        
        // Choose optimal scoring strategy (MINIMIZE total score)
        int strategy1Score = pairs * 2;                    // 2 pts/pair, unused double-x cards give 0
        int strategy2Score = pairs + (unusedDoubleX / 2);  // 1 pt/pair, pair unused double-x for 1 pt each
        
        int finalScore = min(strategy1Score, strategy2Score) + usedDoubleX;
        
        return finalScore;
    }
};
```
