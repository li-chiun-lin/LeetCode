# Hard

There is an endless straight line populated with some robots and walls. You are given integer arrays $robots$, $distance$, and $walls$:

- $robots[i]$ is the position of the $i$-th robot.
- $distance[i]$ is the maximum distance the $i$-th robot's bullet can travel.
- $walls[j]$ is the position of the $j$-th wall.

Every robot has one bullet that can either fire to the left or the right at most $distance[i]$ meters.

A bullet destroys every wall in its path that lies within its range. Robots are fixed obstacles: if a bullet hits another robot before reaching a wall, it immediately stops at that robot and cannot continue.

Return the maximum number of unique walls that can be destroyed by the robots.

Notes:

- A wall and a robot may share the same position; the wall can be destroyed by the robot at that position.
- Robots are not destroyed by bullets.

```cpp
class Solution {
public:
    /**
     * Calculates the maximum number of walls that can be destroyed by robots.
     * Each robot has a position and attack distance, and can destroy walls within its range.
     * 
     * Strategy:
     * 1. Sort robots by position for easier processing
     * 2. Count walls at robot positions (guaranteed destroyable)
     * 3. Use dynamic programming to optimally assign remaining walls to robots
     * 4. Handle edge cases for leftmost and rightmost robots
     * 
     * Time Complexity: O(m log m + w log w + m*w) where m = robots, w = walls
     * Space Complexity: O(m + w)
     */
    int maxWalls(vector<int>& robots, vector<int>& distance, vector<int>& walls) {
        int numRobots = robots.size();
        if (numRobots == 0) return 0;
        
        // Step 1: Create and sort robot-distance pairs by position
        vector<pair<int, int>> robotData(numRobots);
        for (int i = 0; i < numRobots; ++i) {
            robotData[i] = {robots[i], distance[i]};
        }
        sort(robotData.begin(), robotData.end());
        
        // Extract sorted positions and distances
        for (int i = 0; i < numRobots; ++i) {
            robots[i] = robotData[i].first;
            distance[i] = robotData[i].second;
        }
        
        // Step 2: Separate walls into guaranteed hits and contestable walls
        sort(walls.begin(), walls.end());
        
        unordered_set<int> robotPositions(begin(robots), end(robots));
        
        // Count walls at robot positions (guaranteed destroyable)
        int guaranteedWalls = 0;
        vector<int> contestableWalls;
        contestableWalls.reserve(walls.size());
        
        for (int wallPos : walls) {
            if (robotPositions.count(wallPos)) {
                ++guaranteedWalls;
            } else {
                contestableWalls.push_back(wallPos);
            }
        }
        
        int numContestableWalls = contestableWalls.size();
        if (numContestableWalls == 0) return guaranteedWalls;
        
        // Helper functions for binary search on contestable walls
        auto lowerBoundIndex = [&](int value) {
            return int(lower_bound(contestableWalls.begin(), contestableWalls.end(), value) - contestableWalls.begin());
        };
        
        auto upperBoundIndex = [&](int value) {
            return int(upper_bound(contestableWalls.begin(), contestableWalls.end(), value) - contestableWalls.begin());
        };
        
        // Step 3: Calculate walls destroyable by leftmost robot alone
        int leftmostWalls = 0;
        if (numRobots > 0) {
            int leftRobotPos = robots[0];
            int leftAttackRange = distance[0];
            int leftBoundary = leftRobotPos - leftAttackRange;
            
            int wallsUpToRobot = lowerBoundIndex(leftRobotPos);
            int wallsUpToBoundary = lowerBoundIndex(leftBoundary);
            leftmostWalls = max(0, wallsUpToRobot - wallsUpToBoundary);
        }
        
        // Step 4: Calculate walls destroyable by rightmost robot alone
        int rightmostWalls = 0;
        if (numRobots > 0) {
            int rightRobotPos = robots[numRobots - 1];
            int rightAttackRange = distance[numRobots - 1];
            
            int wallsAfterRobot = upperBoundIndex(rightRobotPos);
            int wallsUpToMaxRange = upperBoundIndex(rightRobotPos + rightAttackRange);
            rightmostWalls = max(0, wallsUpToMaxRange - wallsAfterRobot);
        }
        
        // Step 5: Precompute interaction values between adjacent robots
        vector<int> leftRobotOnly(max(0, numRobots - 1));   // Walls only left robot can destroy
        vector<int> rightRobotOnly(max(0, numRobots - 1));  // Walls only right robot can destroy
        vector<int> bothRobots(max(0, numRobots - 1));      // Walls both robots can destroy
        
        for (int i = 0; i + 1 < numRobots; ++i) {
            int leftPos = robots[i];
            int rightPos = robots[i + 1];
            int leftRange = distance[i];
            int rightRange = distance[i + 1];
            
            // Find walls in the gap between robots (exclusive)
            int gapStartIdx = lowerBoundIndex(leftPos + 1);
            int gapEndIdx = lowerBoundIndex(rightPos);
            
            if (gapStartIdx >= gapEndIdx) {
                leftRobotOnly[i] = rightRobotOnly[i] = bothRobots[i] = 0;
                continue;
            }
            
            // Walls reachable only by left robot
            int leftMaxReach = min(rightPos - 1, leftPos + leftRange);
            if (leftMaxReach < leftPos + 1) {
                leftRobotOnly[i] = 0;
            } else {
                leftRobotOnly[i] = max(0, lowerBoundIndex(leftMaxReach + 1) - gapStartIdx);
            }
            
            // Walls reachable only by right robot
            int rightMinReach = max(leftPos + 1, rightPos - rightRange);
            if (rightMinReach > rightPos - 1) {
                rightRobotOnly[i] = 0;
            } else {
                rightRobotOnly[i] = max(0, gapEndIdx - lowerBoundIndex(rightMinReach));
            }
            
            // Walls reachable by both robots (overlap region)
            int overlapLeft = max(leftPos + 1, rightPos - rightRange);
            int overlapRight = min(rightPos - 1, leftPos + leftRange);
            if (overlapLeft > overlapRight) {
                bothRobots[i] = 0;
            } else {
                bothRobots[i] = max(0, lowerBoundIndex(overlapRight + 1) - lowerBoundIndex(overlapLeft));
            }
        }
        
        // Step 6: Dynamic Programming to find optimal assignment
        // dp[i][0] = max walls if robot i attacks left
        // dp[i][1] = max walls if robot i attacks right
        int dpLeft = leftmostWalls;   // Previous state: robot attacks left
        int dpRight = 0;              // Previous state: robot attacks right
        
        for (int i = 1; i < numRobots; ++i) {
            int gapIdx = i - 1;
            
            // Current robot attacks left
            int newDpLeft = max(dpLeft + rightRobotOnly[gapIdx], 
                               dpRight + (leftRobotOnly[gapIdx] + rightRobotOnly[gapIdx] - bothRobots[gapIdx]));
            
            // Current robot attacks right  
            int newDpRight = max(dpLeft + 0, dpRight + leftRobotOnly[gapIdx]);
            
            dpLeft = newDpLeft;
            dpRight = newDpRight;
        }
        
        // Step 7: Add rightmost robot's contribution and return total
        int maxContestableWalls = max(dpLeft, dpRight + rightmostWalls);
        return maxContestableWalls + guaranteedWalls;
    }
};
```
