# Hard

You are given a non-negative integer $n$.

A non-negative integer is called binary-palindromic if its binary representation (written without leading zeros) reads the same forward and backward.

Return the number of integers $k$ such that $0 \leq k \leq n$ and the binary representation of $k$ is a palindrome.

```cpp
#include <bit>
#include <vector>

class Solution {
private:
    // Creates a palindrome by mirroring the given prefix
    // For even length: mirror the entire prefix
    // For odd length: mirror all but the middle bit of the prefix
    long long createPalindrome(long long prefix, int total_length) const {
        long long palindrome = prefix;
        long long mirror_part = (total_length % 2 == 0) ? prefix : (prefix >> 1);
        
        // Reverse and append the mirror part bit by bit
        while (mirror_part > 0) {
            palindrome = (palindrome << 1) | (mirror_part & 1);
            mirror_part >>= 1;
        }
        
        return palindrome;
    }

public:
    // Counts binary palindromes from 1 to n (inclusive)
    int countBinaryPalindromes(long long n) {
        // Precompute count of palindromes for each bit length
        // palindrome_count[i] = number of i-bit binary palindromes
        std::vector<int> palindrome_count(56, 0);
        palindrome_count[1] = 1;  // Only "1"
        palindrome_count[2] = 1;  // Only "11" (3 = "11" in binary)
        
        // For length i, we have 2^((i-1)/2) palindromes
        // We only choose the first half, the second half is determined
        for (int length = 3; length <= 55; length++) {
            palindrome_count[length] = 2 * palindrome_count[length - 2];
        }
        
        // Get the bit length of n
        int bit_length = std::bit_width(static_cast<unsigned long long>(n));
        if (bit_length == 0) return 1;  // n = 0, but we count from 1, so return 1
        
        long long total_count = 1;  // Count "0" as a palindrome
        
        // Step 1: Count all palindromes with fewer bits than n
        for (int length = 1; length < bit_length; length++) {
            total_count += palindrome_count[length];
        }
        
        // Step 2: Count palindromes with same bit length as n but value ≤ n
        int half_length = (bit_length + 1) / 2;  // Length of the prefix we need to choose
        long long min_prefix = 1LL << (half_length - 1);    // Smallest valid prefix
        long long max_prefix = (1LL << half_length) - 1;     // Largest possible prefix
        
        // Binary search to find the largest prefix that creates palindrome ≤ n
        long long left = min_prefix, right = max_prefix;
        long long largest_valid_prefix = min_prefix - 1;
        
        while (left <= right) {
            long long mid = (left + right) >> 1;
            long long palindrome = createPalindrome(mid, bit_length);
            
            if (palindrome <= n) {
                largest_valid_prefix = mid;
                left = mid + 1;   // Try larger prefix
            } else {
                right = mid - 1;  // Try smaller prefix
            }
        }
        
        // Add count of valid same-length palindromes
        if (largest_valid_prefix >= min_prefix) {
            total_count += (largest_valid_prefix - min_prefix + 1);
        }
        
        return static_cast<int>(total_count);
    }
};
```
