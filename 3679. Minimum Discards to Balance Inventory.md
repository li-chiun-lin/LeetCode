# Medium

You are given two integers $w$ and $m$, and an integer array $arrivals$, where $arrivals[i]$ is the type of item arriving on day $i$ (days are 1-indexed).

Items are managed according to the following rules:

- Each arrival may be kept or discarded; an item may only be discarded on its arrival day.
- For each day $i$, consider the window of days $[max(1, i - w + 1), i]$ (the $w$ most recent days up to day $i$):
  - For any such window, each item type may appear at most $m$ times among kept arrivals whose arrival day lies in that window.
  - If keeping the arrival on day $i$ would cause its type to appear more than $m$ times in the window, that arrival must be discarded.

Return the minimum number of arrivals to be discarded so that every $w$-day window contains at most $m$ occurrences of each type.

```cpp
class Solution
{
public:
    int minArrivalsToDiscard(vector<int>& arrivals, int w, int m)
    {
        int n = arrivals.size();
        if (n == 0) return 0;

        unordered_map<int, int> freq;   // type -> count of kept items in current window
        vector<bool> kept(n, false);    // track whether each arrival was kept
        int discarded = 0;

        for (int i = 0; i < n; i++)
        {
            // Remove the item that falls out of the w-day window (if it was kept)
            int expired = i - w;
            if (expired >= 0 && kept[expired])
            {
                freq[arrivals[expired]]--;
            }

            int type = arrivals[i];
            // Decide whether to keep or discard
            if (freq[type] < m)
            {
                kept[i] = true;
                freq[type]++;
            }
            else
            {
                discarded++;
            }
        }

        return discarded;
    }
};
```
