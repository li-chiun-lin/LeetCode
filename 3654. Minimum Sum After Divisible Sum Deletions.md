# Medium

You are given an integer array $nums$ and an integer $k$.

You may repeatedly choose any contiguous subarray of $nums$ whose sum is divisible by $k$ and delete it; after each deletion, the remaining elements close the gap.

Return the minimum possible sum of $nums$ after performing any number of such deletions.

```cpp
class Solution {
public:
    long long minArraySum(vector<int>& nums, int k) {
        int n = nums.size();
        
        // dp[i] = minimum sum after processing first i elements
        vector<long long> dp(n + 1, 0);
        
        // minDp[r] = minimum dp[j] for all j where prefixSum[j] % k == r
        vector<long long> minDp(k, LLONG_MAX);
        
        int remainder = 0;
        minDp[0] = 0; // Base case: empty prefix has sum 0 and remainder 0
        
        for (int i = 0; i < n; i++) {
            remainder = (remainder + nums[i]) % k; // Update running remainder
            
            // Option 1: Keep nums[i] (don't delete any subarray ending at i)
            dp[i + 1] = dp[i] + nums[i];
            
            // Option 2: Delete some subarray ending at position i
            // If we can find position j where prefixSum[j] % k == remainder,
            // then subarray [j+1...i] has sum divisible by k and can be deleted
            if (minDp[remainder] != LLONG_MAX) {
                dp[i + 1] = min(dp[i + 1], minDp[remainder]);
            }
            
            // Update minDp for this remainder for future use
            minDp[remainder] = min(minDp[remainder], dp[i + 1]);
        }
        
        return dp[n];
    }
};
```
