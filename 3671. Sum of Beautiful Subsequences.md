# Hard

You are given an integer array $nums$ of length $n$.

For every positive integer $g$, we define the beauty of $g$ as the product of $g$ and the number of strictly increasing subsequences of $nums$ whose greatest common divisor (GCD) is exactly $g$.

Return the sum of beauty values for all positive integers $g$.

Since the answer could be very large, return it modulo $10^9 + 7$.

```cpp
class Solution {
    const static int MOD = 1e9 + 7;

    // Fenwick Tree (Binary Indexed Tree) supporting point updates and prefix sums
    struct FenwickTree
    {
        int n;
        vector<int> bit;

        FenwickTree(int n) : n(n), bit(n + 1, 0) {}

        // Add value v at index i
        void add(int i, int v)
        {
            for (; i <= n; i += i & -i) {
                bit[i] += v;
                if (bit[i] >= MOD) bit[i] -= MOD;
            }
        }

        // Get prefix sum up to index i
        int sum(int i)
        {
            long long s = 0;
            for (; i > 0; i -= i & -i) {
                s += bit[i];
                if (s >= MOD) s -= MOD;
            }
            return (int)s;
        }
    };
    
public:
    int totalBeauty(vector<int>& nums) {
        int n = nums.size();

        // Find maximum value in nums
        int maxVal = *max_element(nums.begin(), nums.end());

        // Precompute divisors for each number
        vector<vector<int>> divisors(maxVal + 1);
        for (int d = 1; d <= maxVal; ++d) {
            for (int m = d; m <= maxVal; m += d) {
                divisors[m].push_back(d);
            }
        }

        // A[d] = all numbers divisible by d
        vector<vector<int>> A(maxVal + 1);
        for (int x : nums) {
            for (int d : divisors[x]) {
                A[d].push_back(x);
            }
        }

        // num_inc[d] = #increasing subsequences in A[d]
        vector<int> num_inc(maxVal + 1, 0);

        // Function to count increasing subsequences in a sequence
        auto countIncreasing = [&](const vector<int>& seq) -> int {
            if (seq.empty()) return 0;

            // Coordinate compression
            vector<int> vals = seq;
            sort(vals.begin(), vals.end());
            vals.erase(unique(vals.begin(), vals.end()), vals.end());

            FenwickTree ft(vals.size());

            long long total = 0;
            for (int v : seq) {
                // Find compressed index
                int idx = int(lower_bound(vals.begin(), vals.end(), v) - vals.begin()) + 1;

                int smallerCount = ft.sum(idx - 1);
                int newCount = smallerCount + 1;
                if (newCount >= MOD) newCount -= MOD;

                ft.add(idx, newCount);

                total += newCount;
                if (total >= MOD) total -= MOD;
            }
            return (int)(total % MOD);
        };

        // Compute num_inc[d]
        for (int d = 1; d <= maxVal; ++d) {
            if (!A[d].empty()) {
                num_inc[d] = countIncreasing(A[d]);
            }
        }

        // MÃ¶bius-like sieve to get exact gcd = d subsequences
        vector<int> dp(maxVal + 1, 0);
        for (int d = maxVal; d >= 1; --d) {
            long long v = num_inc[d];
            for (int multiple = d + d; multiple <= maxVal; multiple += d) {
                v -= dp[multiple];
                if (v < 0) v += MOD;
            }
            dp[d] = (int)v;
        }

        // Final weighted sum
        long long ans = 0;
        for (int d = 1; d <= maxVal; ++d) {
            if (dp[d]) {
                ans = (ans + 1LL * d * dp[d]) % MOD;
            }
        }
        return (int)ans;
    }
};
```
