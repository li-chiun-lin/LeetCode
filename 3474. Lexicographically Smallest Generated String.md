# Hard

You are given two strings, $str1$ and $str2$, of lengths $n$ and $m$, respectively.

A string $word$ of length $n + m - 1$ is defined to be generated by $str1$ and $str2$ if it satisfies the following conditions for each index $0 \leq i \leq n - 1$:

- If $str1[i]$ == 'T', the substring of $word$ with size $m$ starting at index $i$ is equal to $str2$, i.e., $word[i..(i + m - 1)] == str2$.
- If $str1[i]$ == 'F', the substring of $word$ with size $m$ starting at index $i$ is not equal to $str2$, i.e., $word[i..(i + m - 1)] \ne str2$.

Return the lexicographically smallest possible string that can be generated by $str1$ and $str2$. If no string can be generated, return an empty string "".

```cpp
class Solution {
public:
    string generateString(string pattern, string subsequence) 
    {
        int n = pattern.size(), m = subsequence.size();
        int resultLength = n + m - 1;
        
        // Initialize result with placeholder '?' and track fixed positions.
        string result(resultLength, '?');
        vector<bool> fixedPositions(resultLength, false);

        // Step 1: Place `subsequence` wherever 'T' appears in `pattern`.
        for (int i = 0; i < n; i++) 
        {
            if (pattern[i] == 'T') 
            {
                for (int j = 0; j < m; j++) 
                {
                    int index = i + j;

                    // If position is unassigned, set it.
                    if (result[index] == '?') 
                    {
                        result[index] = subsequence[j];
                        fixedPositions[index] = true;
                    } 
                    else 
                    {
                        // Conflict: If the character does not match, return an empty string.
                        if (result[index] != subsequence[j]) 
                            return "";
                        
                        fixedPositions[index] = true;
                    }
                }
            }
        }

        // Step 2: Fill remaining '?' positions with 'a'.
        for (int i = 0; i < resultLength; i++) 
        {
            if (result[i] == '?') 
                result[i] = 'a';
        }

        // Step 3: Ensure 'F' positions in `pattern` do not match `subsequence`.
        for (int i = 0; i < n; i++) 
        {
            if (pattern[i] == 'F') 
            {
                bool isMatching = true;

                // Check if `subsequence` appears at this position.
                for (int j = 0; j < m; j++) 
                {
                    if (result[i + j] != subsequence[j]) 
                    {
                        isMatching = false;
                        break;
                    }
                }

                // If a match is found, attempt to modify one position.
                if (isMatching) 
                {
                    bool modified = false;

                    // Modify the last possible unfixed position if possible.
                    for (int j = m - 1; j >= 0; j--) 
                    {
                        int index = i + j;

                        if (!fixedPositions[index] && result[index] == 'a' && subsequence[j] == 'a') 
                        {
                            result[index] = 'b';
                            modified = true;
                            break;
                        }
                    }

                    // If no modification was possible, return an empty string.
                    if (!modified) 
                        return "";
                }
            }
        }

        return result;
    }
};
```
