# Hard

You are given an integer array $nums$.

A subsequence is stable if it does not contain three consecutive elements with the same parity when the subsequence is read in order (i.e., consecutive inside the subsequence).

Return the number of stable subsequences.

Since the answer may be too large, return it modulo $10^9 + 7$.

```cpp
class Solution {
    static constexpr int MOD = 1e9 + 7;
    
    long long dfs(const vector<int>& nums, int idx, int prevParity, int consecutiveCount, 
                   vector<vector<vector<long long>>>& memo)
    {
        // Base case: processed all elements
        if (idx == nums.size()) return 1;
        
        // Convert prevParity from {-1, 0, 1} to {0, 1, 2} for array indexing
        int parityIdx = prevParity + 1;
        
        // Return cached result if available
        if (memo[idx][parityIdx][consecutiveCount] != -1) {
            return memo[idx][parityIdx][consecutiveCount];
        }
        
        int currentParity = nums[idx] & 1;
        long long totalWays = 0;
        
        // Option 1: Skip current element
        totalWays = dfs(nums, idx + 1, prevParity, consecutiveCount, memo);
        
        // Option 2: Include current element (if valid)
        if (currentParity == prevParity) {
            // Same parity as previous - check consecutive limit
            if (consecutiveCount < 2) {
                long long includeWays = dfs(nums, idx + 1, currentParity, consecutiveCount + 1, memo);
                totalWays = (totalWays + includeWays) % MOD;
            }
            // If consecutiveCount == 2, we cannot include (would make 3 consecutive)
        } else {
            // Different parity or first element - always safe to include
            long long includeWays = dfs(nums, idx + 1, currentParity, 1, memo);
            totalWays = (totalWays + includeWays) % MOD;
        }
        
        // Cache and return result
        return memo[idx][parityIdx][consecutiveCount] = totalWays;
    }
    
public:
    int countStableSubsequences(vector<int>& nums) {
        int n = nums.size();
        
        // dp[index][parity_mapped][consecutive_count]
        // parity_mapped: {-1,0,1} -> {0,1,2}
        // consecutive_count: {0,1,2}
        vector<vector<vector<long long>>> dp(n, 
            vector<vector<long long>>(3, vector<long long>(3, -1)));
        
        // Subtract 1 to exclude empty subsequence
        long long result = dfs(nums, 0, -1, 0, dp) - 1;
        return (result + MOD) % MOD; // Handle negative result properly
    }
};
```

```cpp
class Solution {
    static constexpr int MOD = 1e9 + 7;
    
public:
    int countStableSubsequences(vector<int>& nums) {
        int n = nums.size();
        if (n == 0) return 0;
        
        // dp[i][parity][count] = number of ways to form stable subsequences
        // considering first i elements, with last element having parity 'parity'
        // and 'count' consecutive elements of same parity at the end
        // parity: 0=even, 1=odd, 2=no element chosen yet
        vector<vector<vector<long long>>> dp(n + 1, 
            vector<vector<long long>>(3, vector<long long>(3, 0)));
        
        // Base case: empty subsequence
        dp[0][2][0] = 1; // 2 means no parity chosen yet
        
        for (int i = 0; i < n; i++) {
            int parity = nums[i] & 1;
            
            // Copy all previous states (skip current element)
            for (int p = 0; p < 3; p++) {
                for (int c = 0; c < 3; c++) {
                    dp[i + 1][p][c] = dp[i][p][c];
                }
            }
            
            // Add current element to existing subsequences
            for (int prevParity = 0; prevParity < 3; prevParity++) {
                for (int prevCount = 0; prevCount < 3; prevCount++) {
                    if (dp[i][prevParity][prevCount] == 0) continue;
                    
                    if (prevParity == 2) {
                        // First element in subsequence
                        dp[i + 1][parity][1] = (dp[i + 1][parity][1] + dp[i][prevParity][prevCount]) % MOD;
                    } else if (prevParity == parity) {
                        // Same parity - can extend if count < 2
                        if (prevCount < 2) {
                            dp[i + 1][parity][prevCount + 1] = 
                                (dp[i + 1][parity][prevCount + 1] + dp[i][prevParity][prevCount]) % MOD;
                        }
                    } else {
                        // Different parity - reset count to 1
                        dp[i + 1][parity][1] = (dp[i + 1][parity][1] + dp[i][prevParity][prevCount]) % MOD;
                    }
                }
            }
        }
        
        // Sum all non-empty subsequences
        long long result = 0;
        for (int p = 0; p < 2; p++) { // Only count actual parities (0,1), not 2
            for (int c = 1; c < 3; c++) { // Only count non-zero consecutive counts
                result = (result + dp[n][p][c]) % MOD;
            }
        }
        
        return result;
    }
};
```
