# Medium

You are given two integer arrays $nums1$ and $nums2$, each of length $n$. You may perform the following split-and-merge operation on $nums1$ any number of times:

- Choose a subarray $nums1[L..R]$.
- Remove that subarray, leaving the prefix $nums1[0..L-1]$ (empty if $L = 0$) and the suffix $nums1[R+1..n-1]$ (empty if $R = n - 1$).
- Re-insert the removed subarray (in its original order) at any position in the remaining array (i.e., between any two elements, at the very start, or at the very end).

Return the minimum number of split-and-merge operations needed to transform $nums1$ into $nums2$.

```cpp
class Solution {
    vector<int> operation(const vector<int>& nums, int L, int R, int C) {
        const int n = nums.size();

        // 1. Extract the subarray to be removed (nums[L...R])
        // Using a range constructor for efficiency
        vector<int> removed_subarray(nums.begin() + L, nums.begin() + R + 1);

        // 2. Build the remaining array by concatenating the prefix and suffix
        vector<int> remaining_array;
        // Add elements from the prefix (nums[0...L-1])
        remaining_array.insert(remaining_array.end(), nums.begin(), nums.begin() + L);
        // Add elements from the suffix (nums[R+1...n-1])
        remaining_array.insert(remaining_array.end(), nums.begin() + R + 1, nums.end());

        // 3. Re-insert the removed subarray at position C in the remaining array
        // The C parameter is a 0-indexed position within the 'remaining_array'.
        // std::vector::insert handles C being at the beginning (0) or end (remaining_array.size()).
        remaining_array.insert(remaining_array.begin() + C, removed_subarray.begin(), removed_subarray.end());

        return remaining_array;
    }
    
public:
    int minSplitMerge(vector<int>& nums1, vector<int>& nums2) {
        int ans = 0;
        int n = size(nums1);
        set<vector<int>> visited;
        queue<vector<int>> que;

        que.push(nums1);

        while (int w = size(que))
        {
            while (w --)
            {
                auto u = que.front();
                que.pop();

                if (u == nums2)
                    return ans;

                for (int L = 0; L < n; ++L)
                    for (int R = L; R < n; ++R) {
                        // Calculate the size of the remaining array after removal
                        int removed_subarray_size = R - L + 1;
                        int remaining_array_size = n - removed_subarray_size;

                        // C should range from 0 to remaining_array_size (inclusive)
                        for (int C = 0; C <= remaining_array_size; ++C)
                        {
                            auto v = operation(u, L, R, C);

                            if (visited.count(v))
                                continue;

                            visited.insert(v);
                            que.push(v);
                        }
                    }
            }

            ++ ans;
        }

        return -1;
    }
};
```
