# Hard

You are given three integers $n$, $l$, and $r$.

A ZigZag array of length $n$ is defined as follows:

- Each element lies in the range $[l, r]$.
- No two adjacent elements are equal.
- No three consecutive elements form a strictly increasing or strictly decreasing sequence.

Return the total number of valid ZigZag arrays.

Since the answer may be large, return it modulo $10^9 + 7$.

```cpp
class Solution {
public:
    int zigZagArrays(int n, int l, int r) {
        const long long MOD = 1000000007;
        int valueRange = r - l + 1;  // Number of distinct values in range [l, r]
        
        // --- INITIALIZE DP TABLE ---
        // dpTable[j][direction] represents ways to place value (l+j) at current position
        // direction 0: came from increasing sequence (previous value was smaller)
        // direction 1: came from decreasing sequence (previous value was larger)
        vector<vector<long long>> dpTable(valueRange, vector<long long>(2, 1));
        
        // Base case: at the last position, we can place any value with either direction
        // (there's no previous constraint to satisfy)
        
        // --- PREFIX SUM ARRAYS ---
        // These will store cumulative sums to enable O(1) range queries
        vector<long long> increasingSum(valueRange + 1);
        vector<long long> decreasingSum(valueRange + 1);
        
        // --- PROCESS EACH POSITION FROM RIGHT TO LEFT ---
        // Build the DP solution from position n-2 down to position 0
        for (int position = n - 2; position >= 0; --position) {
            
            // Step 1: Calculate prefix sums for current DP state
            increasingSum[0] = 0;
            decreasingSum[0] = 0;
            
            for (int valueIndex = 0; valueIndex < valueRange; ++valueIndex) {
                increasingSum[valueIndex + 1] = 
                    (increasingSum[valueIndex] + dpTable[valueIndex][0]) % MOD;
                decreasingSum[valueIndex + 1] = 
                    (decreasingSum[valueIndex] + dpTable[valueIndex][1]) % MOD;
            }
            
            // Step 2: Update DP table for current position
            // The key insight: the original code has a specific pattern for state transitions
            for (int valueIndex = 0; valueIndex < valueRange; ++valueIndex) {
                // New state 0: sum of all decreasing states up to current value
                // This represents: current value can be reached from any smaller value
                // that was in a "decreasing" state
                long long newState0 = decreasingSum[valueIndex];
                
                // New state 1: sum of all increasing states from current value + 1 to end
                // This represents: current value can be reached from any larger value  
                // that was in an "increasing" state
                long long newState1 = (increasingSum[valueRange] - increasingSum[valueIndex + 1] + MOD) % MOD;
                
                // Update the DP table with calculated values
                dpTable[valueIndex][0] = newState0;
                dpTable[valueIndex][1] = newState1;
            }
        }
        
        // --- CALCULATE FINAL RESULT ---
        // Sum all possible ways to start the zigzag array
        long long totalWays = 0;
        for (const auto& valueState : dpTable) {
            totalWays = (totalWays + valueState[0]) % MOD;
            totalWays = (totalWays + valueState[1]) % MOD;
        }
        
        return totalWays;
    }
};
```
