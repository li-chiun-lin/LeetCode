# Medium

You are climbing a staircase with $n + 1$ steps, numbered from $0$ to $n$.

You are also given a 1-indexed integer array $costs$ of length $n$, where $costs[i]$ is the cost of step $i$.

From step $i$, you can jump only to step $i + 1$, $i + 2$, or $i + 3$. The cost of jumping from step $i$ to step $j$ is defined as: $costs[j] + (j - i)^2$

You start from step $0$ with $cost = 0$.

Return the minimum total cost to reach step $n$.

```cpp
class Solution {
    static const int IMPOSSIBLE = 1000000000;  // Large value representing impossible path
    
    int calculateMinCost(int n, vector<int>& costs, int currentStep, vector<int>& memo) {
        // Base cases
        if (currentStep == n) {
            return 0;  // Reached target - no additional cost
        }
        
        if (currentStep > n) {
            return IMPOSSIBLE;  // Overshot target - invalid path
        }
        
        // Return cached result if already computed
        if (memo[currentStep] != -1) {
            return memo[currentStep];
        }
        
        int minCostFromHere = IMPOSSIBLE;
        
        // Try all possible step sizes: 1, 2, or 3 steps
        for (int stepSize = 1; stepSize <= 3; ++stepSize) {
            int nextStep = currentStep + stepSize;
            
            // Only consider valid next steps (don't exceed target)
            if (nextStep <= n) {
                // Calculate total cost for this move:
                // 1. Base cost of landing on nextStep: costs[nextStep-1] 
                // 2. Penalty cost: stepSizeÂ² (quadratic penalty for larger jumps)
                int baseCost = costs[nextStep - 1];
                int penaltyCost = stepSize * stepSize;
                int moveCost = baseCost + penaltyCost;
                
                // Add cost of optimal path from nextStep to target
                int totalCost = calculateMinCost(n, costs, nextStep, memo) + moveCost;
                
                // Update minimum cost
                minCostFromHere = min(minCostFromHere, totalCost);
            }
        }
        
        // Cache and return result
        return memo[currentStep] = minCostFromHere;
    }
    
public:
    int climbStairs(int n, vector<int>& costs) {
        // Initialize memoization array
        // memo[i] = minimum cost to reach step n starting from step i
        vector<int> memo(n + 1, -1);  // Fixed: size n+1 to handle positions 0 through n
        
        // Start calculation from step 0
        return calculateMinCost(n, costs, 0, memo);
    }
};
```

```cpp
class Solution {
public:
    int climbStairs(int n, vector<int>& costs) {
        const int IMPOSSIBLE = 1000000000;  // Large value representing impossible path
        // Initialize DP table
        // dp[i] = minimum cost to reach step n starting from step i
        vector<int> dp(n + 1, IMPOSSIBLE);
        
        // Base cases (exactly matching original recursive version)
        dp[n] = 0;           // Already at target - no cost
        
        // Fill table bottom-up: from step n-1 down to step 0
        for (int currentStep = n - 1; currentStep >= 0; currentStep--) {
            int minCostFromHere = IMPOSSIBLE;
            
            // Try all possible step sizes: 1, 2, or 3 steps
            // This exactly mirrors: for (int k = 1; k <= 3; ++k)
            for (int stepSize = 1; stepSize <= 3; stepSize++) {
                int nextStep = currentStep + stepSize;  // This was 'j = i + k'
                
                // Only consider valid next steps (don't exceed target)
                // This exactly mirrors: if (j <= n)
                if (nextStep <= n) {
                    int baseCost = costs[nextStep - 1];
                    int penaltyCost = stepSize * stepSize; 
                    int moveCost = baseCost + penaltyCost;
                    
                    // Add cost of optimal path from nextStep to target
                    // This exactly mirrors: int d = dfs(n, costs, j, dp) + c;
                    int totalCost = dp[nextStep] + moveCost;
                    
                    // Update minimum cost
                    // This exactly mirrors: ans = min(ans, d);
                    minCostFromHere = min(minCostFromHere, totalCost);
                }
            }
            
            // Store computed result
            // This exactly mirrors: return dp[i] = ans;
            dp[currentStep] = minCostFromHere;
        }
        
        // Return result (equivalent to calling dfs(n, costs, 0, dp))
        return dp[0];
    }
};
```
