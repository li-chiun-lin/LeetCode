# Hard

You are given an integer array $nums$.

You want to maximize the alternating sum of $nums$, which is defined as the value obtained by adding elements at even indices and subtracting elements at odd indices. That is, $nums[0] - nums[1] + nums[2] - nums[3]...$

You are also given a 2D integer array $swaps$ where $swaps[i] = [p_i, q_i]$. For each pair $[p_i, q_i]$ in swaps, you are allowed to swap the elements at indices $p_i$ and $q_i$. These swaps can be performed any number of times and in any order.

Return the maximum possible alternating sum of $nums$.

```cpp
class Solution {
public:
    long long maxAlternatingSum(vector<int>& nums, vector<vector<int>>& swaps) {
        int n = nums.size();
        
        // --- UNION-FIND DATA STRUCTURE ---
        // parent[i] represents the parent of element i in the union-find tree
        vector<int> parent(n);
        iota(parent.begin(), parent.end(), 0);  // Initialize each element as its own parent
        
        /**
         * Find operation with path compression
         * Finds the root representative of the set containing x
         */
        function<int(int)> findRoot = [&](int x) -> int {
            if (parent[x] != x) {
                parent[x] = findRoot(parent[x]);  // Path compression optimization
            }
            return parent[x];
        };
        
        /**
         * Union operation - connects two elements into the same set
         * Elements in the same set can be swapped (directly or transitively)
         */
        auto unionSets = [&](int x, int y) -> void {
            int rootX = findRoot(x);
            int rootY = findRoot(y);
            if (rootX != rootY) {
                parent[rootX] = rootY;  // Merge sets by making one root point to another
            }
        };
        
        // --- BUILD CONNECTED COMPONENTS ---
        // Process all allowed swaps to build equivalence classes
        for (const auto& swap : swaps) {
            unionSets(swap[0], swap[1]);
        }
        
        // Group indices by their root representative
        // Each group contains indices that can be freely rearranged among themselves
        map<int, vector<int>> swappableGroups;
        for (int i = 0; i < n; ++i) {
            swappableGroups[findRoot(i)].push_back(i);
        }
        
        // --- OPTIMIZE EACH GROUP INDEPENDENTLY ---
        long long maxAlternatingSum = 0;
        
        for (const auto& [groupRoot, indices] : swappableGroups) {
            // Collect all values in this swappable group
            vector<int> groupValues;
            vector<int> positionTypeCounts(2, 0);  // [even_positions, odd_positions]
            
            for (int index : indices) {
                groupValues.push_back(nums[index]);
                positionTypeCounts[index % 2]++;  // Count even (0) and odd (1) positions
            }
            
            // Sort values in descending order to assign largest values optimally
            sort(groupValues.rbegin(), groupValues.rend());
            
            // --- GREEDY ASSIGNMENT STRATEGY ---
            // In alternating sum: even indices contribute (+), odd indices contribute (-)
            // Strategy: Assign largest values to even positions (positive contribution)
            //          Assign remaining values to odd positions (negative contribution)
            
            int valueIndex = 0;
            
            // Assign largest values to even positions (these will be added)
            int evenPositionsCount = positionTypeCounts[0];
            for (int i = 0; i < evenPositionsCount; ++i) {
                maxAlternatingSum += groupValues[valueIndex++];
            }
            
            // Assign remaining values to odd positions (these will be subtracted)
            while (valueIndex < groupValues.size()) {
                maxAlternatingSum -= groupValues[valueIndex++];
            }
        }
        
        return maxAlternatingSum;
    }
};
```
