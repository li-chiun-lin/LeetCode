# Medium

You are given a circular array $balance$ of length $n$, where $balance[i]$ is the net balance of person $i$.

In one move, a person can transfer exactly 1 unit of balance to either their left or right neighbor.

Return the minimum number of moves required so that every person has a non-negative balance. If it is impossible, return $-1$.

Note: You are guaranteed that at most 1 index has a negative balance initially.

```cpp
class Solution {
public:
    long long minMoves(vector<int>& balance) {
        if (accumulate(begin(balance), end(balance), 0LL) < 0)
            return -1;

        int n = size(balance);
        long long ans = 0;
        int idx = 0;

        while (idx < n && balance[idx] >= 0)
            ++ idx;

        if (idx == n)
            return 0;

        for (int dst = 1; dst < n && balance[idx] < 0; ++dst)
        {
            int v = balance[(idx - dst + n) % n] + balance[(idx + dst) % n];
            long long u = min(v, -balance[idx]);
            balance[idx] += u;
            ans += u * dst;
        }

        return ans;
    }
};
```
