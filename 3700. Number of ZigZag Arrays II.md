# Hard

You are given three integers $n$, $l$, and $r$.

A ZigZag array of length $n$ is defined as follows:

- Each element lies in the range $[l, r]$.
- No two adjacent elements are equal.
- No three consecutive elements form a strictly increasing or strictly decreasing sequence.

Return the total number of valid ZigZag arrays.

Since the answer may be large, return it modulo $10^9 + 7$.

```cpp
class Solution {
private:
    static const int MOD = 1000000007;
    
    vector<vector<int>> multiplyMatrices(const vector<vector<int>>& matrixA, 
                                        const vector<vector<int>>& matrixB) {
        int m = matrixA.size();
        vector<vector<int>> result(m, vector<int>(m, 0));
        
        for (int i = 0; i < m; ++i) {
            for (int k = 0; k < m; ++k) {
                if (matrixA[i][k] == 0) continue;  // Skip if multiplier is zero
                
                long long multiplier = matrixA[i][k];
                for (int j = 0; j < m; ++j) {
                    if (matrixB[k][j] != 0) {
                        result[i][j] = (result[i][j] + multiplier * matrixB[k][j]) % MOD;
                    }
                }
            }
        }
        
        return result;
    }
    
    vector<int> multiplyMatrixVector(const vector<vector<int>>& matrix, 
                                   const vector<int>& vec) {
        int m = matrix.size();
        vector<int> result(m, 0);
        
        for (int i = 0; i < m; ++i) {
            long long sum = 0;
            for (int k = 0; k < m; ++k) {
                if (matrix[i][k] != 0 && vec[k] != 0) {
                    sum += 1LL * matrix[i][k] * vec[k];
                    if (sum >= (1LL << 62)) sum %= MOD;  // Prevent overflow
                }
            }
            result[i] = sum % MOD;
        }
        
        return result;
    }
    
    vector<vector<int>> matrixPower(vector<vector<int>> base, long long exponent) {
        int m = base.size();
        vector<vector<int>> result(m, vector<int>(m, 0));
        
        // Initialize result as identity matrix
        for (int i = 0; i < m; ++i) {
            result[i][i] = 1;
        }
        
        while (exponent > 0) {
            if (exponent & 1) {
                result = multiplyMatrices(result, base);
            }
            base = multiplyMatrices(base, base);
            exponent >>= 1;
        }
        
        return result;
    }
    
public:
    int zigZagArrays(int n, int l, int r) {
        int valueCount = r - l + 1;  // Number of distinct values available
        
        // Handle base cases
        if (n == 1) return valueCount % MOD;
        if (n == 2) return (1LL * valueCount * (valueCount - 1)) % MOD;
        
        // --- BUILD TRANSITION MATRICES ---
        // Matrix A: transitions from smaller to larger values (increasing)
        vector<vector<int>> increasingMatrix(valueCount, vector<int>(valueCount, 0));
        // Matrix B: transitions from larger to smaller values (decreasing)  
        vector<vector<int>> decreasingMatrix(valueCount, vector<int>(valueCount, 0));
        
        for (int i = 0; i < valueCount; ++i) {
            // Fill upper triangle: can go from value i to any larger value j
            for (int j = i + 1; j < valueCount; ++j) {
                increasingMatrix[i][j] = 1;
            }
            // Fill lower triangle: can go from value i to any smaller value j
            for (int j = 0; j < i; ++j) {
                decreasingMatrix[i][j] = 1;
            }
        }
        
        // --- CREATE COMPOSITE MATRICES FOR 2-STEP CYCLES ---
        // P = A×B: represents increase→decrease cycle
        auto P = multiplyMatrices(increasingMatrix, decreasingMatrix);
        // Q = B×A: represents decrease→increase cycle  
        auto Q = multiplyMatrices(decreasingMatrix, increasingMatrix);
        
        // --- INITIALIZE STATE VECTORS ---
        // These represent the number of ways to reach each value as second element
        vector<int> increasingStartVector(valueCount);  // After an increasing step
        vector<int> decreasingStartVector(valueCount);  // After a decreasing step
        
        for (int i = 0; i < valueCount; ++i) {
            // increasingStartVector[i] = number of smaller values that can reach value i
            increasingStartVector[i] = valueCount - 1 - i;
            // decreasingStartVector[i] = number of larger values that can reach value i
            decreasingStartVector[i] = i;
        }
        
        // --- APPLY MATRIX POWERS BASED ON REMAINING STEPS ---
        long long remainingSteps = n - 2;  // Steps after placing first two elements
        vector<int> finalIncreasingStates, finalDecreasingStates;
        
        if (remainingSteps % 2 == 0) {
            // Even remaining steps: use direct cycle powers
            auto P_powered = matrixPower(P, remainingSteps / 2);
            auto Q_powered = matrixPower(Q, remainingSteps / 2);
            
            finalIncreasingStates = multiplyMatrixVector(P_powered, increasingStartVector);
            finalDecreasingStates = multiplyMatrixVector(Q_powered, decreasingStartVector);
        } else {
            // Odd remaining steps: need one extra transition
            auto P_powered = matrixPower(P, remainingSteps / 2);
            auto Q_powered = matrixPower(Q, remainingSteps / 2);
            
            // Apply partial cycle then final single transition
            auto tempDecreasing = multiplyMatrixVector(Q_powered, decreasingStartVector);
            auto tempIncreasing = multiplyMatrixVector(P_powered, increasingStartVector);
            
            finalIncreasingStates = multiplyMatrixVector(increasingMatrix, tempDecreasing);
            finalDecreasingStates = multiplyMatrixVector(decreasingMatrix, tempIncreasing);
        }
        
        // --- CALCULATE FINAL ANSWER ---
        long long totalCount = 0;
        
        // Sum contributions from increasing-start sequences
        for (int i = 0; i < valueCount; ++i) {
            totalCount += finalIncreasingStates[i];
            if (totalCount >= MOD) totalCount %= MOD;
        }
        
        // Sum contributions from decreasing-start sequences  
        for (int i = 0; i < valueCount; ++i) {
            totalCount += finalDecreasingStates[i];
            if (totalCount >= MOD) totalCount %= MOD;
        }
        
        return totalCount % MOD;
    }
};
```
