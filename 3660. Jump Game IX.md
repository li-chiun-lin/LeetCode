# Medium

You are given an integer array $nums$.

From any index $i$, you can jump to another index $j$ under the following rules:

- Jump to index $j$ where $j > i$ is allowed only if $nums[j] < nums[i]$.
- Jump to index $j$ where $j < i$ is allowed only if $nums[j] > nums[i]$.

For each index $i$, find the maximum value in $nums$ that can be reached by following any sequence of valid jumps starting at $i$.

Return an array $ans$ where $ans[i]$ is the maximum value reachable starting from index $i$.

```cpp
class Solution {
public:
    vector<int> maxValue(vector<int>& values) {
        int n = values.size();
        if (n == 0) return {};
        
        // Build prefix maximum array - prefixMax[i] = max(values[0..i])
        vector<int> prefixMax(n);
        prefixMax[0] = values[0];
        for (int i = 1; i < n; i++) {
            prefixMax[i] = max(prefixMax[i-1], values[i]);
        }
        
        // Build suffix minimum array - suffixMin[i] = min(values[i..n-1])
        vector<int> suffixMin(n);
        suffixMin[n-1] = values[n-1];
        for (int i = n-2; i >= 0; i--) {
            suffixMin[i] = min(suffixMin[i+1], values[i]);
        }
        
        // Result array to store the final answer
        vector<int> result(n);
        
        // Process array in sections where monotonic property can be maintained
        int sectionStart = 0;
        
        for (int i = 0; i < n-1; i++) {
            // Check if we can split here: current section's max <= next section's min
            if (prefixMax[i] <= suffixMin[i+1]) {
                // Fill current section [sectionStart..i] with the section's maximum
                int sectionMax = prefixMax[i];
                for (int k = sectionStart; k <= i; k++) {
                    result[k] = sectionMax;
                }
                sectionStart = i + 1;  // Start new section
            }
        }
        
        // Fill the final section [sectionStart..n-1] with overall maximum
        int finalSectionMax = prefixMax[n-1];
        for (int k = sectionStart; k < n; k++) {
            result[k] = finalSectionMax;
        }
        
        return result;
    }
};
```
