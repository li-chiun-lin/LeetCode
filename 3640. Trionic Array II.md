# Hard

You are given an integer array $nums$ of length $n$.

A trionic subarray is a contiguous subarray $nums[l...r]$ (with $0 \leq l < r < n$) for which there exist indices $l < p < q < r$ such that:

- $nums[l...p]$ is strictly increasing,
- $nums[p...q]$ is strictly decreasing,
- $nums[q...r]$ is strictly increasing.

Return the maximum sum of any trionic subarray in $nums$.

```cpp
// Generic Segment Tree that supports range minimum or maximum queries
class SegmentTree {
    int size;
    vector<long long> tree;
    bool isMinTree;

public:
    // Constructor: builds a segment tree for either min or max based on the flag
    SegmentTree(const vector<long long>& data, bool buildMinTree) {
        isMinTree = buildMinTree;
        size = 1;
        while (size < (int)data.size()) size <<= 1;
        tree.assign(2 * size, buildMinTree ? LLONG_MAX : LLONG_MIN);

        // Initialize leaves with input data
        for (int i = 0; i < (int)data.size(); ++i)
            tree[size + i] = data[i];

        // Build internal nodes
        for (int i = size - 1; i > 0; --i)
            tree[i] = isMinTree
                ? min(tree[i << 1], tree[i << 1 | 1])
                : max(tree[i << 1], tree[i << 1 | 1]);
    }

    // Query the range [left, right]
    long long query(int left, int right) {
        long long result = isMinTree ? LLONG_MAX : LLONG_MIN;
        for (left += size, right += size; left <= right; left >>= 1, right >>= 1) {
            if (left & 1)
                result = isMinTree ? min(result, tree[left++]) : max(result, tree[left++]);
            if (!(right & 1))
                result = isMinTree ? min(result, tree[right--]) : max(result, tree[right--]);
        }
        return result;
    }

    // Update element at index
    void update(int index, long long value) {
        index += size;
        tree[index] = value;
        for (index >>= 1; index > 0; index >>= 1)
            tree[index] = isMinTree
                ? min(tree[index << 1], tree[index << 1 | 1])
                : max(tree[index << 1], tree[index << 1 | 1]);
    }
};

class Solution {
public:
    // Main function to compute the maximum sum of a "trionic" subarray
    long long maxSumTrionic(vector<int>& nums) {
        int n = nums.size();

        // Step 1: Compute prefix sums for fast range sum calculations
        vector<long long> prefixSum(n + 1, 0);
        for (int i = 0; i < n; ++i)
            prefixSum[i + 1] = prefixSum[i] + nums[i];

        // Step 2: Preprocess monotonic segment lengths
        vector<int> incLen(n), decLen(n), rightIncLen(n);
        incLen[0] = decLen[0] = 1;

        // incLen[i] = length of increasing sequence ending at i
        // decLen[i] = length of decreasing sequence ending at i
        for (int i = 1; i < n; ++i) {
            incLen[i] = (nums[i] > nums[i - 1]) ? incLen[i - 1] + 1 : 1;
            decLen[i] = (nums[i] < nums[i - 1]) ? decLen[i - 1] + 1 : 1;
        }

        // rightIncLen[i] = length of increasing sequence starting at i
        rightIncLen[n - 1] = 1;
        for (int i = n - 2; i >= 0; --i)
            rightIncLen[i] = (nums[i] < nums[i + 1]) ? rightIncLen[i + 1] + 1 : 1;

        // Step 3: Build segment trees on prefix sums
        SegmentTree prefixMinTree(prefixSum, true);   // for left subarray (min)
        SegmentTree prefixMaxTree(prefixSum, false);  // for right subarray (max)

        // Step 4: Compute best left contributions using increasing subarrays
        vector<long long> leftContribution(n, LLONG_MIN);

        for (int i = 1; i < n; ++i) {
            if (incLen[i] > 1) {
                int leftStart = i - incLen[i] + 1;
                int leftEnd = i - 1;
                long long minPrefix = prefixMinTree.query(leftStart, leftEnd);
                // Store negative prefix sum to later add to suffix max for total sum
                leftContribution[i] = -minPrefix;
            }
        }

        // Step 5: Segment tree for DP (to get best left contribution fast)
        SegmentTree leftDpTree(leftContribution, false);

        // Step 6: For each valid middle point, combine left + middle + right
        long long maxTrionicSum = LLONG_MIN;

        for (int peak = 1; peak < n - 1; ++peak) {
            // A valid peak must be part of a decreasing then increasing shape
            if (decLen[peak] > 1 && rightIncLen[peak] > 1) {
                // Left increasing segment range
                int leftRangeStart = peak - decLen[peak] + 1;
                int leftRangeEnd = peak - 1;
                long long bestLeft = leftDpTree.query(leftRangeStart, leftRangeEnd);
                if (bestLeft == LLONG_MIN) continue;  // no valid left found

                // Right increasing segment range (exclusive of peak)
                int rightRangeStart = peak + 2;
                int rightRangeEnd = peak + rightIncLen[peak];
                if (rightRangeStart > rightRangeEnd || rightRangeEnd > n) continue;

                long long bestRight = prefixMaxTree.query(rightRangeStart, rightRangeEnd);

                // Total sum = best left contribution + best right prefix
                maxTrionicSum = max(maxTrionicSum, bestLeft + bestRight);
            }
        }

        return maxTrionicSum;
    }
};
```
