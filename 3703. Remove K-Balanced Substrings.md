# Medium

You are given a string $s$ consisting of '(' and ')', and an integer $k$.

A string is $k$-balanced if it is exactly $k$ consecutive '(' followed by $k$ consecutive ')'.

You must repeatedly remove all non-overlapping $k$-balanced substrings from $s$, and then join the remaining parts. Continue this process until no $k$-balanced substring exists.

Return the final string after all possible removals.

```cpp
class Solution {
public:
    string removeSubstring(string s, int k) {
        // Store consecutive groups of same characters as (character, count) pairs
        // Example: "((()))" with k=2 -> [('(', 3), (')', 3)]
        vector<pair<char, int>> groups;
       
        // Process each character in the input string
        for (char c : s) {
            // If current character matches the last group, increment its count
            if (!groups.empty() && groups.back().first == c) {
                groups.back().second++;
            } else {
                // Otherwise, start a new group for this character
                groups.push_back({c, 1});
            }
            
            // After adding the character, check if we can remove a k-balanced substring
            int n = size(groups);
            if (n >= 2) {
                // Get references to the last two groups
                auto& [v1, c1] = groups[n - 2];  // Second-to-last group
                auto& [v2, c2] = groups[n - 1];  // Last group
               
                // Check if we have k opening parens followed by k closing parens
                // Pattern: "...(((...)))" where we have at least k '(' and exactly k ')'
                if (v1 == '(' && c1 >= k && v2 == ')' && c2 == k) {
                    // Remove k opening parentheses from the opening group
                    c1 -= k;
                    
                    // Remove the entire closing group (it has exactly k characters)
                    groups.pop_back();
                   
                    // If the opening group is now empty, remove it too
                    if (c1 == 0) {
                        groups.pop_back();
                    }
                }
            }
        }
        
        // Reconstruct the final string from remaining groups
        string result;
        for (const auto& [ch, count] : groups) {
            // Append 'count' copies of character 'ch'
            result += string(count, ch);
        }
        return result;
    }
};
```
