# Medium

You are given a directed, weighted graph with $n$ nodes labeled from $0$ to $n - 1$, and an array $edges$ where $edges[i] = [u_i, v_i, w_i]$ represents a directed edge from node $u_i$ to node $v_i$ with cost $w_i$.

Each node $u_i$ has a switch that can be used at most once: when you arrive at $u_i$ and have not yet used its switch, you may activate it on one of its incoming edges $v_i → u_i$ reverse that edge to $u_i → v_i$ and immediately traverse it.

The reversal is only valid for that single move, and using a reversed edge costs $2 \times w_i$.

Return the minimum total cost to travel from node $0$ to node $n - 1$. If it is not possible, return $-1$.

```cpp
class Solution {
public:
    int minCost(int n, vector<vector<int>>& edges) {
        // Create an adjacency list where each node maps to a list of (neighbor, cost) pairs
        vector<vector<pair<int, int>>> graph(n);

        // Build the graph: edge from u to v with cost w, and from v to u with cost 2*w
        for (const auto& edge : edges) {
            int u = edge[0], v = edge[1], w = edge[2];
            graph[u].emplace_back(v, w);       // Normal cost
            graph[v].emplace_back(u, 2 * w);   // Double cost in reverse direction
        }

        // Distance vector initialized to infinity; distance to node 0 is 0
        vector<int> distance(n, INT_MAX);
        distance[0] = 0;

        // Min-heap priority queue to process nodes by shortest known distance
        using pii = pair<int, int>; // (distance, node)
        priority_queue<pii, vector<pii>, greater<>> minHeap;
        minHeap.emplace(0, 0); // Start from node 0

        while (!minHeap.empty()) {
            auto [currDist, u] = minHeap.top();
            minHeap.pop();

            // Skip if we already found a better path to u
            if (currDist > distance[u]) continue;

            // Relax edges
            for (const auto& [v, weight] : graph[u]) {
                if (distance[v] > distance[u] + weight) {
                    distance[v] = distance[u] + weight;
                    minHeap.emplace(distance[v], v);
                }
            }
        }

        // If destination node is unreachable, return -1
        return distance[n - 1] == INT_MAX ? -1 : distance[n - 1];
    }
};
```
